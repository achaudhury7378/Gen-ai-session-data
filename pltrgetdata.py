# robust_foundry_projects_list.py
# Requires: pip install foundry-platform-sdk
import os
import sys
from typing import Optional

# recommended auth helpers per README
import foundry_sdk

# Use either a user bearer token for dev/test:
#   export FOUNDRY_TOKEN="ey..."
# or configure the hostname:
#   export FOUNDRY_HOSTNAME="example.palantirfoundry.com"
#
# If you prefer OAuth client credentials, see ConfidentialClientAuth in README.
token = os.environ.get("FOUNDRY_TOKEN")
hostname = os.environ.get("FOUNDRY_HOSTNAME") or "https://<your-foundry-host>"

if not token:
    print("Warning: FOUNDRY_TOKEN not found in env. Set FOUNDRY_TOKEN to a user/service bearer token.")
# Initialize client (the README suggests FoundryClient + UserTokenAuth)
auth = foundry_sdk.UserTokenAuth(token) if token else None
client = foundry_sdk.FoundryClient(auth=auth, hostname=hostname)

# navigate to the v2 filesystem client; this is the supported pattern in README
svc = getattr(client, "v2", None)
if svc is None:
    print("ERROR: client.v2 not available. Inspecting client attributes:", file=sys.stderr)
    print(dir(client), file=sys.stderr)
    raise SystemExit(1)

filesystem = getattr(svc, "filesystem", None)
if filesystem is None:
    print("ERROR: client.v2.filesystem not available. Inspecting client.v2 attributes:", file=sys.stderr)
    print(dir(svc), file=sys.stderr)
    raise SystemExit(1)

# helper to find a callable method from candidate names
def find_method(obj, candidates):
    for name in candidates:
        if hasattr(obj, name):
            meth = getattr(obj, name)
            if callable(meth):
                return meth, name
    return None, None

# candidates based on common autogenerated SDK naming patterns
project_candidates = [
    "list_projects", "projects_list", "filesystem_projects_list",
    "get_projects", "get_all_projects", "list_projects_with_http_info"
]
folder_children_candidates = [
    "list_folder_children", "folders_children", "folders_get_children",
    "get_folder_children", "get_folders_children", "folders_children_get",
    "folders_get_children_with_http_info", "folders_children_with_http_info"
]

list_projects_meth, lp_name = find_method(filesystem, project_candidates)
if not list_projects_meth:
    print("Could not find a projects-listing method. Available filesystem methods:")
    print("\n".join(sorted([n for n in dir(filesystem) if not n.startswith("_")])))
    raise SystemExit(1)

print(f"Using filesystem.{lp_name}() to list projects")

# call projects listing (handle pagination if SDK returns a page object)
projects_resp = list_projects_meth(page_size=200) if "page_size" in list_projects_meth.__code__.co_varnames else list_projects_meth()
# attempt to extract items
projects = []
if isinstance(projects_resp, dict) and "items" in projects_resp:
    projects = projects_resp["items"]
elif hasattr(projects_resp, "items"):
    try:
        projects = projects_resp.items
    except Exception:
        # fallback: try to iterate
        projects = list(projects_resp)
else:
    # fallback: try to iterate result
    try:
        projects = list(projects_resp)
    except Exception:
        print("Unable to parse projects response; printing raw response and exiting")
        print(projects_resp)
        raise SystemExit(1)

print(f"Found {len(projects)} projects (first 10):")
for p in projects[:10]:
    # print a couple of common fields if present
    print(" -", p.get("name") if isinstance(p, dict) else getattr(p, "name", repr(p)))

# find folder-children method
list_children_meth, lc_name = find_method(filesystem, folder_children_candidates)
if not list_children_meth:
    print("Could not find a folder-children method. Available filesystem methods:")
    print("\n".join(sorted([n for n in dir(filesystem) if not n.startswith("_")])))
    raise SystemExit(1)

print(f"Using filesystem.{lc_name}() to list folder children")

# helper to get project root folder RID (field names differ across versions)
def get_project_root_folder_rid(proj):
    # typical fields seen in responses
    if isinstance(proj, dict):
        return proj.get("rootFolderRid") or (proj.get("rootFolder") or {}).get("rid") or proj.get("folderRid")
    else:
        return getattr(proj, "root_folder_rid", None) or getattr(proj, "rootFolderRid", None) or getattr(proj, "rootFolder", None)

# recursive walk of folders
def walk_folder(folder_rid, collect):
    # call the folder children method; adapt param name if required
    kwargs = {}
    # try common param names
    if "folder_rid" in list_children_meth.__code__.co_varnames:
        kwargs["folder_rid"] = folder_rid
    elif "folderRid" in list_children_meth.__code__.co_varnames:
        kwargs["folderRid"] = folder_rid
    elif "folderRid" in list_children_meth.__name__:
        kwargs["folderRid"] = folder_rid
    else:
        # guess positional
        try:
            resp = list_children_meth(folder_rid)
            children_resp = resp
        except TypeError:
            raise
    # if we didn't call it yet:
    if kwargs:
        children_resp = list_children_meth(**kwargs)
    # extract items
    children = []
    if isinstance(children_resp, dict) and "items" in children_resp:
        children = children_resp["items"]
    elif hasattr(children_resp, "items"):
        try:
            children = children_resp.items
        except Exception:
            children = list(children_resp)
    else:
        try:
            children = list(children_resp)
        except Exception:
            children = []
    for c in children:
        # determine if it's a folder or file/resource
        rtype = c.get("resourceType") if isinstance(c, dict) else getattr(c, "resource_type", None)
        rid = c.get("rid") if isinstance(c, dict) else getattr(c, "rid", None)
        name = c.get("name") if isinstance(c, dict) else getattr(c, "name", None)
        path = c.get("path") if isinstance(c, dict) else getattr(c, "path", None)
        if rtype and str(rtype).upper() == "FOLDER":
            walk_folder(rid, collect)
        else:
            collect.append({"rid": rid, "name": name, "path": path, "raw": c})

# collect files for each project
all_files = []
for proj in projects:
    root_folder_rid = get_project_root_folder_rid(proj)
    if not root_folder_rid:
        print(f"Could not find root folder for project: {proj}")
        continue
    files = []
    walk_folder(root_folder_rid, files)
    print(f"Project {proj.get('name') if isinstance(proj, dict) else getattr(proj,'name',None)} -> {len(files)} resources/files")
    all_files.extend(files)

# Print summary CSV to stdout
print("\nRID,NAME,PATH")
for f in all_files:
    rid = f.get("rid") or ""
    name = (f.get("name") or "").replace(",", " ")
    path = (f.get("path") or "").replace(",", " ")
    print(f"{rid},{name},{path}")